<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Talk is cheap, show me the code.">
    <meta name="keyword" content="">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
          Vue源码学习-结合EventLoop看nextTick - Yeoman的博客 | Yeoman&#39;s Blog
        
    </title>

    <link rel="canonical" href="https://yeomanyang.github.io/2018/08/30/Vue源码学习-结合EventLoop看nextTick/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/hux-blog.min.css">

    <!-- Pygments Highlight CSS -->
    <link rel="stylesheet" href="/css/highlight.css">

    <!-- Custom Fonts -->
    <!-- <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="https://cdn.staticfile.org/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">


    <!-- Hux Delete, sad but pending in China
    <link href='https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/
    css'>
    -->


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- ga & ba script hoook -->
    <script></script>
</head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">

    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">Yeoman&#39;s Blog</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>

                    

                        
                    

                        
                        <li>
                            <a href="/about/">About</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/archives/">Archives</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/tags/">Tags</a>
                        </li>
                        
                    

                        
                    
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>


    <!-- Main Content -->
    
<!-- Image to hack wechat -->
<!-- <img src="https://yeomanyang.github.io/img/icon_wechat.png" width="0" height="0"> -->
<!-- <img src="{{ site.baseurl }}/{% if page.header-img %}{{ page.header-img }}{% else %}{{ site.header-img }}{% endif %}" width="0" height="0"> -->

<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        background-image: url('/img/home-bg.png')
    }
</style>
<header class="intro-header">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <div class="tags">
                        
                          <a class="tag" href="/tags/#Frontend" title="Frontend">Frontend</a>
                        
                    </div>
                    <h1>Vue源码学习-结合EventLoop看nextTick</h1>
                    <h2 class="subheading"></h2>
                    <span class="meta">
                        Posted by Yeoman on
                        2018-08-30
                    </span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

    <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                <h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h2><p>Vue中的<code>$nextTick</code>函数算是一个我们开发中出场率比较高的API了，作用是在这个回调中可以保证UI是更新完成之后的内容。</p>
<p>而Event Loop的知识用在工程中的实践并不多见，在<code>$nextTick</code>中这算是一个典型的例子，因此我觉得结合事件循环来看这块儿的源码是非常合适的。</p>
<p>另一方面，这个函数和Node.js中的<code>process.nextTick</code>是同名的。我也一直没去梳理过Node.js中的Event Loop，趁着这个机会深入理解下Node.js中的事件循环。</p>
<blockquote>
<p>虽然说浏览器(Chrome为例)中和Node.js中都是v8作为JS引擎，但是Event Loop并不包含其中，而是在各自的runtime中实现的，也就是说浏览器端是各大浏览器各自实现，而Node.js的这部分实现在libuv中。<br>网上很多文章说浏览器端和Node.js中的事件循环类似我是非常不认同的- -，我觉得两者相差挺大的，毕竟是两套实现。</p>
</blockquote>
<h2 id="2-Event-Loop-in-browsing-contexts"><a href="#2-Event-Loop-in-browsing-contexts" class="headerlink" title="2. Event Loop in browsing contexts"></a>2. Event Loop in browsing contexts</h2><p>前面说过Event Loop是在各自的runtime中实现的，因为浏览器端的Event Loop规范是定义在HTML规范中的。强烈建议有时间的同学直接多看几遍<a href="https://html.spec.whatwg.org/multipage/webappapis.html#event-loops" target="_blank" rel="noopener">WHATWG规范</a>以及Jake Archibald的<a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/" target="_blank" rel="noopener">tasks-microtasks-queues-and-schedules</a>。</p>
<p>我会挑一些我认为最重要的点来记录。</p>
<h3 id="2-1-task-amp-microtask"><a href="#2-1-task-amp-microtask" class="headerlink" title="2.1 task &amp; microtask"></a>2.1 task &amp; microtask</h3><p>Event Loop中有两种任务类型，分别是<em>task</em>和<em>microtask</em>。对应的，这两种任务对应的队列叫<em>task queues</em>和<em>microtask queues</em>。</p>
<h4 id="2-1-1-task-source"><a href="#2-1-1-task-source" class="headerlink" title="2.1.1 task source"></a>2.1.1 task source</h4><p>在规范里提到的<em>task source</em>主要有以下这些：</p>
<ol>
<li>The DOM manipulation task source</li>
</ol>
<blockquote>
<p>比如当一个节点被插入到文档中的时候这是一个非阻塞的事件</p>
</blockquote>
<ol start="2">
<li>The user interaction task source</li>
</ol>
<blockquote>
<p>比如用户点击事件</p>
</blockquote>
<ol start="3">
<li>The networking task source</li>
</ol>
<blockquote>
<p>一些网络请求相关的任务</p>
</blockquote>
<ol start="4">
<li>The history traversal task source</li>
</ol>
<blockquote>
<p>H5的history相关的API，类似history.back()</p>
</blockquote>
<ol start="5">
<li>timer task source</li>
</ol>
<blockquote>
<p>setInterval和setTimeout的callback</p>
</blockquote>
<h4 id="2-1-2-microtask-source"><a href="#2-1-2-microtask-source" class="headerlink" title="2.1.2 microtask source"></a>2.1.2 microtask source</h4><p>规范中并没有明确指出哪些任务是属于<em>microtask</em>的，但是我们通常认为有：</p>
<ol>
<li><p>promise callbacks</p>
</li>
<li><p>mutation observer callbacks</p>
</li>
</ol>
<blockquote>
<ol>
<li>一个Event Loop可以有一个或者多个<em>task queue</em>，但是<em>microtask queue</em>只有一个。</li>
<li>来自相同的<em>task source</em>的任务必须放在一个<em>task queue</em>里面，来自不同<em>task source</em>的<em>task</em>可能在不同的<em>task queue</em>。</li>
</ol>
</blockquote>
<h3 id="2-2-Processing-model"><a href="#2-2-Processing-model" class="headerlink" title="2.2 Processing model"></a>2.2 Processing model</h3><p>清楚了哪些属于<em>task</em>和<em>microtask</em>之后，事件循环的调用机制<em>Processing model</em>用这张图就已经描述得很清楚了，不再列举具体过程。</p>
<p><img src="https://haitao.nos.netease.com/01843b68-bdcc-46be-8ce1-88791cc47602_720_836.jpg"></p>
<p>我们看一段简单的script：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">console.<span class="built_in">log</span>(<span class="string">'script start'</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span><span class="params">()</span></span> &#123;</span><br><span class="line">  console.<span class="built_in">log</span>(<span class="string">'setTimeout'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">Promise.resolve().<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">()</span></span> &#123;</span><br><span class="line">  console.<span class="built_in">log</span>(<span class="string">'promise1'</span>);</span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">()</span></span> &#123;</span><br><span class="line">  console.<span class="built_in">log</span>(<span class="string">'promise2'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.<span class="built_in">log</span>(<span class="string">'script end'</span>);</span><br></pre></td></tr></table></figure>
<p>实际上’promise’输出会在’timeout’之前，而上图中不是分明说是task先执行么？</p>
<p>国内很多的博客把script的执行也认为是一种task，但是我觉得这样的描述并不是准确的，规范中并没有提及这种<em>task source</em>。</p>
<p>然而，在<a href="https://html.spec.whatwg.org/multipage/webappapis.html#calling-scripts" target="_blank" rel="noopener">WHATWG规范</a>的<strong>calling scripts章节</strong>中，我注意到这么一段话：</p>
<p><img src="https://haitao.nos.netease.com/ee2db0a2-9b19-47a3-ac60-656715f8e835_2344_332.jpeg"></p>
<p>也就是说在每次<strong>calling scripts</strong>的<strong>cleanup</strong>阶段，<strong><em>并且当前的JS调用栈是空的情况下</em></strong>，<em>microtask queue</em>都会被执行。</p>
<p>所以我觉得更准确的说法应该是：</p>
<h4 id="2-2-1-microtask被执行的时机"><a href="#2-2-1-microtask被执行的时机" class="headerlink" title="2.2.1 microtask被执行的时机"></a>2.2.1 microtask被执行的时机</h4><ol>
<li>在<strong>calling scripts</strong>的<strong>cleanup</strong>阶段，并且当前的JS调用栈是空的情况下。</li>
</ol>
<blockquote>
<p>关于JS调用栈必须为空这一点在<a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/" target="_blank" rel="noopener">tasks-microtasks-queues-and-schedules</a>这篇文章中用鼠标点击触发click和调用click函数来演示了区别</p>
</blockquote>
<ol start="2">
<li>每个task的结束完成之后。</li>
</ol>
<h3 id="2-3-小结"><a href="#2-3-小结" class="headerlink" title="2.3 小结"></a>2.3 小结</h3><p>浏览器端的Event Loop相对好理解一些，只要清楚<em>task</em>和<em>microtask</em>的划分，以及理清图中的循环过程就好了，当然还要注意<em>microtask</em>的调用时机。</p>
<h2 id="3-Event-Loop-in-Node-js"><a href="#3-Event-Loop-in-Node-js" class="headerlink" title="3. Event Loop in Node.js"></a>3. Event Loop in Node.js</h2><p>如果只是要研究Vue中的<code>nextTick</code>机制的话，了解上面的浏览器中的Event Loop就够了，可以直接跳过这个章节，看第四章节。</p>
<p>同样的，研究Node.js中的Event Loop机制，我们尽量也要看第一手资料。在<a href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/" target="_blank" rel="noopener">Node.js的官方文档</a>中比较详细地描述了Event Loop。</p>
<h3 id="3-1-phase-in-Event-Loop"><a href="#3-1-phase-in-Event-Loop" class="headerlink" title="3.1 phase in Event Loop"></a>3.1 phase in Event Loop</h3><p><img src="https://haitao.nos.netease.com/fe3d9a93-ab89-4bfb-a2a9-e8660287833b_1476_870.jpeg"></p>
<p>光是看这张图就觉得和浏览器中的Event Loop不太一样有木有- -我们来看看每个阶段需要做的事情。</p>
<h4 id="3-1-1-timers"><a href="#3-1-1-timers" class="headerlink" title="3.1.1 timers"></a>3.1.1 timers</h4><p>这个阶段是用来执行<code>setTimeout()</code>和<code>setInterval()</code>这两个timer的callback的阶段。</p>
<p>但是要注意的是，真正控制timer被调用的阶段是在 <strong>poll phase</strong>，我们往下看就知道了。</p>
<h4 id="3-1-2-pending-callbacks"><a href="#3-1-2-pending-callbacks" class="headerlink" title="3.1.2 pending callbacks"></a>3.1.2 pending callbacks</h4><p>这个阶段会执行某些操作系统的回调，比较TCP链接收到<code>ECONNREFUSED</code>回调。</p>
<h4 id="3-1-3-idle-prepare"><a href="#3-1-3-idle-prepare" class="headerlink" title="3.1.3 idle, prepare"></a>3.1.3 idle, prepare</h4><p>只在系统内部调用，我们并不关心。</p>
<h4 id="3-1-4-poll"><a href="#3-1-4-poll" class="headerlink" title="3.1.4 poll"></a>3.1.4 poll</h4><p>轮询阶段可以说是最重要的一个阶段了，这个阶段主要的作用是计算I/O事件需要阻塞的时间，执行I/O事件。</p>
<p>我画了一张图来描述轮询阶段做的事情：</p>
<p><img src="https://haitao.nos.netease.com/a8eac64d-c7c0-4934-a6c7-d33211a787f0_616_587.png"></p>
<p>前面在<em>timer phase</em>那里提到了，实际上控制timers阶段执行的是在poll阶段。为什么这么说呢？</p>
<p>我们设想一个场景，我们开启了一个100ms的timer，同时读取了一个文件，文件读取需要200ms。这个时候在poll阶段是会等文件读取完，然后让循环走到timer阶段，还是在timer到达后立即进入check阶段呢？</p>
<p>我写了个demo进行测试：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">someAsyncOperation</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Assume this takes 95ms to complete</span></span><br><span class="line">  fs.readFile(<span class="string">'/Users/yeoman/Desktop/task.key'</span>, callback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> timeoutScheduled = <span class="built_in">Date</span>.now();</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> delay = <span class="built_in">Date</span>.now() - timeoutScheduled;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;delay&#125;</span>ms have passed since I was scheduled`</span>);</span><br><span class="line">&#125;, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// do someAsyncOperation which takes 95 ms to complete</span></span><br><span class="line">someAsyncOperation(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'read finish'</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>输出的结果有时候是有时候read finish先输出，有时候是read finish后输出。</p>
<p>也就是说在poll阶段，会一直检查是否有timer到达阈值了，同时也会检查I/O的回调是否加到poll queue中了，如果timer先到达了，则会直接进入timer阶段。如果是I/O操作先完成了，则会先执行I/O的回调再进入timer阶段。</p>
<h4 id="3-1-5-check"><a href="#3-1-5-check" class="headerlink" title="3.1.5 check"></a>3.1.5 check</h4><p>这个阶段主要是执行<code>setImmediate</code>这个函数的回调。</p>
<h4 id="3-1-6-close-callbacks"><a href="#3-1-6-close-callbacks" class="headerlink" title="3.1.6 close callbacks"></a>3.1.6 close callbacks</h4><p>这个阶段会处理一些close回调，比如<code>socket.destroy()</code>这个函数的回调会在这个阶段进行。</p>
<h3 id="3-2-setImmediate-vs-setTimeout"><a href="#3-2-setImmediate-vs-setTimeout" class="headerlink" title="3.2 setImmediate() vs setTimeout()"></a>3.2 setImmediate() vs setTimeout()</h3><p>这两个函数的调用时机在上面已经讲的非常清楚了，但是文档中提到了一个有趣的现象。</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'timeout'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'immediate'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这段代码的输出是不固定的，有时候是timeout在先，有时候是immediate在先。但是根据我们之前的理解，setTimeout在timer阶段就会执行了，而setImmediate是在check阶段。</p>
<p>这到底是为什么呢？文档中的解释是这样的：</p>
<blockquote>
<p>For example, if we run the following script which is not within an I/O cycle (i.e. the main module), the order in which the two timers are executed is non-deterministic, as it is bound by the performance of the process</p>
</blockquote>
<p><img src="https://haitao.nos.netease.com/c1e71041-2c04-4f4a-9e01-15f961cf7342.jpg"></p>
<p>和性能有关是闹哪样啊喂！这显然不是我们想要的答案。</p>
<p>百思不得其解之后，我感觉应该只能从看源码来理解这个现象了，但是我们知道<a href="https://github.com/nodejs/node/blob/master/deps/uv/src/unix/core.c#L350" target="_blank" rel="noopener">这块儿代码</a>是属于<strong>libuv</strong>模块的，用C++写的，翻了翻源码之后差点放弃治疗了- -</p>
<p>直到我看到了cnode上的<a href="https://cnodejs.org/topic/57d68794cb6f605d360105bf" target="_blank" rel="noopener">这篇文章的评论</a>，@hyj1991 非常棒的给出了这段核心代码的注释以及解释这个现象的原因。</p>
<p>首先，在Node.js中，我们给<code>setTimeout</code>设置0的延迟和1的延迟是一样的，嗯？阮老师明明告诉我们<code>setTimeout</code>的最小时间是4毫秒呀。</p>
<p>找到<a href="https://github.com/nodejs/node/blob/master/lib/internal/timers.js#L56" target="_blank" rel="noopener">Timeout的代码</a>一看，确实在实现上就是最小是1毫秒，具体原因没有去深究。</p>
<p>那么原因很清晰了，实际上我们的<code>setTimeout</code>是有1ms的延迟的，那么有两种情况：</p>
<ol>
<li>在调用<code>uv__run_timers</code>函数前，初始化loop的时间大于等于1ms，那么这个setTimeout的回调就会直接执行，然后才是<code>setImmediate</code>。</li>
<li>在调用<code>uv__run_timers</code>函数前，初始化loop的时间小于1ms，那么<code>uv__run_timers</code>第一次执行的时候什么都不会发生，直接进入check阶段，也就是调用setImmediate，然后再循环回timer。</li>
</ol>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">fs.readFile(__filename, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timeout'</span>);</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line">  setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'immediate'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>那么如果我们把代码换成这样呢，<code>setImmediate</code>的执行顺序还会是变动的么？相信聪明的你心里已经有答案了。</p>
<p>我们知道，<code>readFile</code>的回调是在poll阶段执行的，那么肯定会先执行check阶段的<code>setImmediate</code>，然后才是timer阶段的<code>setTimeout</code>。</p>
<blockquote>
<p>写到这里有个感受，如果想要深入Node.js的话，还是得具备一些C++代码的阅读能力的，任重而道远- -。</p>
</blockquote>
<h3 id="3-3-process-nextTick"><a href="#3-3-process-nextTick" class="headerlink" title="3.3 process.nextTick"></a>3.3 process.nextTick</h3><p>终于写到这个函数了，我们发现，<code>process.nextTick</code>并不是属于Event Loop的一部分。但是在每一个phase结束之后都会对<code>nextTick queue</code>进行依次调用。</p>
<p>咦，那我们的microtask呢，怎么到现在还没有提到？？？</p>
<p>实际上，<code>microtask queue</code>会跟在<code>nextTick queue</code>之后进行调用。本来想去啃一下这一块儿的源码的，奈何现阶段能力和精力都有限，留到以后再读。但是找到一个<a href="https://www.zhihu.com/question/55557148" target="_blank" rel="noopener">知乎问题</a>，死月大佬的回答从源码角度解释了<code>microtask queue</code>和<code>nextTick queue</code>的调用顺序。</p>
<p>文档中提到，<code>process.nextTick()</code>和<code>setImmediate()</code>的名字本应该换一下，因为<code>process.nextTick()</code>的作用看起来更像是立即调用，而<code>setImmediate()</code>的调用需要等待下一次循环，但是考虑到兼容，现在不太可能去变了。</p>
<p>Node.js官方建议开发者在任何情况下都使用<code>setImmediate()</code>，因为这样更容易理解和更好的平台兼容。</p>
<blockquote>
<p>IE11居然是支持<code>setImmediate()</code>的，惊了个呆</p>
</blockquote>
<p>那么<code>process.nextTick</code>这个函数对于Node.js来说到底有什么意义呢？</p>
<p>文档中举了这个一个例子：</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const server = net.createServer(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;).listen(<span class="number">8080</span>);</span><br><span class="line"></span><br><span class="line">server.<span class="literal">on</span>(<span class="string">'listening'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;);</span><br></pre></td></tr></table></figure>
<p>这段代码的潜在问题是，当我们调用<code>listen(8080)</code>的时候，这时候端口直接被绑定了，但是这时候<code>&#39;listening&#39;</code>的回调函数还没有绑上去呢，那么如何先完成回调函数的绑定，再触发<code>&#39;listening&#39;</code>呢？这个问题就是通过<code>process.nextTick</code>来实现的。</p>
<p>我们去源码里看看，是否真的如文档所说呢？</p>
<p>我们知道，实际上Node.js在创建Server这个API上暴露给开发者的是<code>http</code>模块，因此我们从<a href="https://github.com/nodejs/node/blob/master/lib/_http_server.js" target="_blank" rel="noopener">这个文件</a>找起，最终定位到<a href="https://github.com/nodejs/node/blob/master/lib/net.js#L1359" target="_blank" rel="noopener">net.js的_listen2函数</a>。这个函数在完成端口监听之后，会进行这样的函数调用：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">defaultTriggerAsyncIdScope(<span class="keyword">this</span>[async_id_symbol],</span><br><span class="line">                             process.nextTick,</span><br><span class="line">                             emitListeningNT,</span><br><span class="line">                             <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">emitListeningNT</span><span class="params">(self)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ensure handle hasn't closed</span></span><br><span class="line">  <span class="keyword">if</span> (self._handle)</span><br><span class="line">    self.emit(<span class="string">'listening'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defaultTriggerAsyncIdScope</span><span class="params">(triggerAsyncId, block, <span class="rest_arg">...args</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (triggerAsyncId === <span class="literal">undefined</span>)</span><br><span class="line">    <span class="keyword">return</span> Reflect.apply(block, <span class="literal">null</span>, args);</span><br><span class="line">  <span class="comment">// CHECK(Number.isSafeInteger(triggerAsyncId))</span></span><br><span class="line">  <span class="comment">// CHECK(triggerAsyncId &gt; 0)</span></span><br><span class="line">  <span class="keyword">const</span> oldDefaultTriggerAsyncId = async_id_fields[kDefaultTriggerAsyncId];</span><br><span class="line">  async_id_fields[kDefaultTriggerAsyncId] = triggerAsyncId;</span><br><span class="line"></span><br><span class="line">  let ret;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    ret = Reflect.apply(block, <span class="literal">null</span>, args);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    async_id_fields[kDefaultTriggerAsyncId] = oldDefaultTriggerAsyncId;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出来，<code>self.emit(&#39;listening&#39;);</code>函数是在 <code>process.nextTick</code>中进行调用的。而等到这个执行的时候，<code>&#39;listening&#39;</code>的回调已经绑定完成了。</p>
<p>官方文档果然比大部分文章靠谱多了，诚不欺我（逃</p>
<h3 id="3-4-小结"><a href="#3-4-小结" class="headerlink" title="3.4 小结"></a>3.4 小结</h3><p>关于Node.js的事件循环实际上花了挺长的时间去找资料和理解，但是总体来讲还是觉得很值。</p>
<p>相信看完了2，3两节内容并充分消化的同学，再去网上找那些异步函数各种嵌套调用顺序的题目，肯定都能迎刃而解了～</p>
<h2 id="4-Vue的nextTick"><a href="#4-Vue的nextTick" class="headerlink" title="4. Vue的nextTick"></a>4. Vue的nextTick</h2><p>前面花了太多的时间来讲Event Loop，终于要回到我们的主题Vue了。</p>
<h3 id="4-1-nextTick的作用"><a href="#4-1-nextTick的作用" class="headerlink" title="4.1 nextTick的作用"></a>4.1 nextTick的作用</h3><p>因为这篇文章的重点是结合Event Loop来看Vue的<code>nextTick</code>。因此我假设读者已经了解Vue的响应式原理。也就是说默认读者是知道下面这段代码实际上发生了什么的（这里的title是响应式的）：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mounted () &#123;</span><br><span class="line">  <span class="keyword">this</span>.title = <span class="string">'young'</span>;</span><br><span class="line">  <span class="keyword">this</span>.title = <span class="string">'simple'</span>;</span><br><span class="line">  <span class="keyword">this</span>.$nextTick(() =&gt; &#123;</span><br><span class="line">    <span class="keyword">this</span>.title = <span class="string">'naive'</span>;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当title的setter被触发之后，对应的<code>RenderWatcher</code>会调用<code>update</code>方法，然后调用<a href="https://github.com/vuejs/vue/blob/dev/src/core/observer/scheduler.js#L130" target="_blank" rel="noopener">scheduler.js中的queueWatcher</a>方法把自身加到调度器的队列中，然后执行<code>nextTick(flushSchedulerQueue)</code>。这里我们先暂且认为<code>nextTick</code>就是一个异步API，类似于<code>process.nextTick</code>。那把这个更新操作做成异步的好处是什么呢？</p>
<blockquote>
<p>$nextTick就是调用了这个内部的nextTick函数</p>
</blockquote>
<p>代码中我们看到，我们先对title进行了两次赋值，假设这时候我们直接同步更新，页面会进行一次渲染。而第二次title再次变化，又会进行一次渲染。显然，第一次的渲染是没有意义的，这对性能来说是极大的浪费。</p>
<p>这个时候我们就想到说，如果我们把更新操作放在<code>setTimeout</code>中，那这样就会等到同步代码全部调用结束之后再执行更新操作了。（也就是说title的setter会被触发两次，而实际上每一个Watcher都有id，因此第二次在触发的时候因为这个id的<code>RenderWatcher</code>已经存在了，所以不会被push到queue中）。这样，虽然我们对title进行了两次赋值，但是只会批量执行一次更新，这就是Vue内部nextTick函数的意义。</p>
<p>那么这样是否就完美了呢？</p>
<p>我们知道<code>setTimeout</code>是会生成一个<em>task</em>，而这个<em>task</em>会在当前的<em>task</em>结束之后在下一次循环中调用。那么就意味着，当前的<em>task</em>执行完成之后，就需要Render UI。然后执行<code>setTimeout</code>又会再一次Render UI，显然这不是最优的方案。</p>
<p>显然如果用<code>microtask</code>，比如<code>Promise</code>来取代<code>setTimeout</code>是更合适的办法，第二节内容已经讲过，动态添加进来的<code>microtask</code>会在这次循环中直接执行完毕。这样只会执行一次Render UI。</p>
<h3 id="3-2-nextTick的实现"><a href="#3-2-nextTick的实现" class="headerlink" title="3.2 nextTick的实现"></a>3.2 nextTick的实现</h3><p>实际上，Vue内部要比我们考虑得全面，因为他要考虑更多的兼容性，比如<code>Promise</code>在IE11里就是<a href="https://caniuse.com/#search=Promise" target="_blank" rel="noopener">不兼容的</a>。</p>
<p>我们来看下<a href="https://github.com/vuejs/vue/blob/dev/src/core/util/next-tick.js" target="_blank" rel="noopener">内部源码</a>的实现：</p>
<p>我们先看入口函数：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">nextTick</span> (<span class="params">cb?: <span class="built_in">Function</span>, ctx?: <span class="built_in">Object</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> _resolve</span><br><span class="line">  <span class="comment">// 把入参推到callbacks队列中</span></span><br><span class="line">  callbacks.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (cb) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        cb.call(ctx)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        handleError(e, ctx, <span class="string">'nextTick'</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_resolve) &#123;</span><br><span class="line">      _resolve(ctx)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 判断当前是不是处在等待状态</span></span><br><span class="line">  <span class="keyword">if</span> (!pending) &#123;</span><br><span class="line">    pending = <span class="literal">true</span></span><br><span class="line">    <span class="comment">// 某些特殊情况必须要用macrotask</span></span><br><span class="line">    <span class="keyword">if</span> (useMacroTask) &#123;</span><br><span class="line">      macroTimerFunc()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 生成microtask</span></span><br><span class="line">      microTimerFunc()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里不管是macroTimerFunc还是microTimerFunc，都会把整个callbacks队列放进microtask queue或者task queue</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 处理没有传callback的情况</span></span><br><span class="line">  <span class="keyword">if</span> (!cb &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">Promise</span> !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">      _resolve = resolve</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数的作用就是和我们前面举的例子一样，用来把回调任务都放到<em>microtask queue</em>或者是<em>task queue</em>中执行。</p>
<p>然后我们看下<code>macroTimerFunc</code>和<code>microTimerFunc</code>分别是怎么来的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> setImmediate !== <span class="string">'undefined'</span> &amp;&amp; isNative(setImmediate)) &#123;</span><br><span class="line">  macroTimerFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setImmediate(flushCallbacks)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> MessageChannel !== <span class="string">'undefined'</span> &amp;&amp; (</span><br><span class="line">  isNative(MessageChannel) ||</span><br><span class="line">  <span class="comment">// PhantomJS</span></span><br><span class="line">  MessageChannel.toString() === <span class="string">'[object MessageChannelConstructor]'</span></span><br><span class="line">)) &#123;</span><br><span class="line">  <span class="keyword">const</span> channel = <span class="keyword">new</span> MessageChannel()</span><br><span class="line">  <span class="keyword">const</span> port = channel.port2</span><br><span class="line">  channel.port1.onmessage = flushCallbacks</span><br><span class="line">  macroTimerFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    port.postMessage(<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">/* istanbul ignore next */</span></span><br><span class="line">  macroTimerFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setTimeout(flushCallbacks, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Promise</span> !== <span class="string">'undefined'</span> &amp;&amp; isNative(<span class="built_in">Promise</span>)) &#123;</span><br><span class="line">  <span class="keyword">const</span> p = <span class="built_in">Promise</span>.resolve()</span><br><span class="line">  microTimerFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    p.then(flushCallbacks)</span><br><span class="line">    <span class="comment">// 这里尤大注释说明了，iOS有一种特殊的现象就是microtask不会被调用刷新，因此要手动触发一个空的task来调用microtask quque</span></span><br><span class="line">    <span class="keyword">if</span> (isIOS) setTimeout(noop)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 降级成宏任务</span></span><br><span class="line">  microTimerFunc = macroTimerFunc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来总结一下：</p>
<ol>
<li>对于<em>macrotask</em>的选择，最高优先级的是<code>setImmediate</code>，前面我们提过这个只在IE中实现了，然后则是<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MessageChannel" target="_blank" rel="noopener">MessageChannel</a>，最后才是<code>setTimeout</code>，至于为什么<code>setTimeout</code>是最低优先级的，我觉得一来是因为这个接口在浏览器端有最低4ms的延迟，二来是需要监听timeout，在性能上相比前两种直接调用要差一些。</li>
<li>在<em>microtask</em>的选择上，最高优先级的是<code>Promise</code>，如果不支持<code>Promise</code>的话直接降级成宏任务。（以前版本还有<code>MutationObserver</code>的，我查了下<code>Promise</code>和<code>MutationObserver</code>的兼容性差不多，不知道尤大是不是出于这个原因废弃了）</li>
</ol>
<h3 id="3-3-nextTick的原理"><a href="#3-3-nextTick的原理" class="headerlink" title="3.3 $nextTick的原理"></a>3.3 $nextTick的原理</h3><p>实际上，我们上面讲的<code>nextTick</code>相关的部分都是Vue内部的<code>nextTick</code>实现，好像还没有提到我们开发中使用<code>$nextTick</code>函数最重要的那个作用呢。</p>
<figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"title"</span>&gt;</span></span><span class="template-variable">&#123;&#123; title &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">mounted () &#123;</span></span><br><span class="line"><span class="xml">  this.title = 'young';</span></span><br><span class="line"><span class="xml">  this.title = 'simple';</span></span><br><span class="line"><span class="xml">  this.$nextTick(() =&gt; &#123;</span></span><br><span class="line"><span class="xml">    console.log(document.getElementById('title').innerText);</span></span><br><span class="line"><span class="xml">    // simple</span></span><br><span class="line"><span class="xml">    this.title = 'naive';</span></span><br><span class="line"><span class="xml">  &#125;)</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>我们再来看这段伪代码，我们在<code>$nextTick</code>是可以拿到最新的DOM的。（实际工作中我们经常会去拿$refs，也是同理的）</p>
<p>也就是说这个<code>$nextTick</code>回调可以保证我们能获取到前面的同步代码执行完之后的最新DOM。其实原理也已经比较清楚了，我们画一张图更清楚地描述这个过程。</p>
<p><img src="https://haitao.nos.netease.com/4116eb44-bdde-4a19-a384-0ff9df6d033d_1213_393.png"></p>
<ol>
<li>在执行完<code>this.title = &#39;young&#39;;this.title = &#39;simple&#39;;</code>之后，会把<code>flushSchedulerQueue</code>（也就是Watcher的集合）推到nextTick的callback队列中</li>
<li>生成一个<em>microtask</em>，并且把<code>nextTick</code>的<code>callbacks</code>队列作为这个miscrotask的回调函数</li>
<li>执行<code>this.$nextTick(() =&gt; {})</code>之后，实际就是调用Vue内部的nextTick函数，同样把自己的回调推到<code>nextTick</code>的<code>callbacks</code>队列。但是因为这时候<code>pending</code>参数为true，所以不会生成一个新的microtask。</li>
<li>执行<em>microtask</em>，首先会执行<code>flushSchedulerQueue</code>里的<code>RenderWatcher</code>，内部会执行patch，更新DOM。</li>
<li>然后执行我们在<code>$nextTick</code>中传入的回调，注意，这个时候虽然浏览器还没有进行渲染，因为<em>microtask</em>还没有执行结束，但是我们DOM已经在第四步同步更新完了，所以这时候我们可以拿到最新的DOM。</li>
<li><em>microtask</em>执行结束，浏览器渲染。</li>
</ol>
<p>至此<code>$nextTick</code>的原理已经完全解释清楚了～</p>
<h3 id="3-4-one-more-thing"><a href="#3-4-one-more-thing" class="headerlink" title="3.4 one more thing"></a>3.4 one more thing</h3><p>那么是不是<em>microtask</em>就一定优于<em>macrotask</em>呢？在<a href="https://github.com/vuejs/vue/blob/dev/src/core/util/next-tick.js" target="_blank" rel="noopener">next-tick.js源码中</a>，有这么一段注释，以及这么一段好像没有被用到的代码。</p>
<blockquote>
<p>// Here we have async deferring wrappers using both microtasks and (macro) tasks.<br>// In &lt; 2.4 we used microtasks everywhere, but there are some scenarios where<br>// microtasks have too high a priority and fire in between supposedly<br>// sequential events (e.g. #4521, #6690) or even between bubbling of the same<br>// event (#6566). However, using (macro) tasks everywhere also has subtle problems<br>// when state is changed right before repaint (e.g. #6813, out-in transitions).<br>// Here we use microtask by default, but expose a way to force (macro) task when<br>// needed (e.g. in event handlers attached by v-on).</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Wrap a function so that if any code inside triggers state change,</span></span><br><span class="line"><span class="comment"> * the changes are queued using a (macro) task instead of a microtask.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">withMacroTask</span> (<span class="params">fn: Function</span>): <span class="title">Function</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> fn._withTask || (fn._withTask = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    useMacroTask = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">const</span> res = fn.apply(<span class="literal">null</span>, <span class="built_in">arguments</span>)</span><br><span class="line">    useMacroTask = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段注释提到了几个issue，大意是说在连续点击或者事件冒泡的场景下，<code>microtask</code>由于执行时机太早会引出一些问题。因此暴露了一个<code>withMacroTask</code>函数用于在某些场景下强制使用<code>macrotask</code>，比如我们在用<code>v-on</code>去绑定UI事件的时候，Vue内部就会强制使用<code>macrotask</code>。</p>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>最近在看Vue源码的过程中，越来越发觉结合实际场景去思考一些技术点是很有帮助的。希望上面的内容可以给你提供一些帮助，当然也有可能是我理解不对的（逃</p>
<h2 id="Refrence"><a href="#Refrence" class="headerlink" title="Refrence"></a>Refrence</h2><p><a href="https://html.spec.whatwg.org/multipage/webappapis.html#event-loops" target="_blank" rel="noopener">WHATWG规范</a></p>
<p><a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/" target="_blank" rel="noopener">tasks-microtasks-queues-and-schedules</a></p>
<p><a href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/" target="_blank" rel="noopener">Node.js文档</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/34229323" target="_blank" rel="noopener">深入理解 JavaScript Event Loop</a></p>
<p><a href="https://cnodejs.org/topic/57d68794cb6f605d360105bf" target="_blank" rel="noopener">这篇文章的评论</a></p>


                <hr>

                

                <ul class="pager">
                    
                        <li class="previous">
                            <a href="/2018/11/19/egg-sequelize以及事务相关/" data-toggle="tooltip" data-placement="top" title="egg-sequelize以及事务相关">&larr; Previous Post</a>
                        </li>
                    
                    
                        <li class="next">
                            <a href="/2018/08/25/Vue源码学习-从keep-alive的bug讲起/" data-toggle="tooltip" data-placement="top" title="Vue源码学习-从keep-alive的bug讲起">Next Post &rarr;</a>
                        </li>
                    
                </ul>

                

                

            </div>
    <!-- Side Catalog Container -->
        

    <!-- Sidebar Container -->

            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
                       
                          <a class="tag" href="/tags/#Frontend" title="Frontend">Frontend</a>
                        
                    </div>
                </section>
                

                <!-- Friends Blog -->
                
                <hr>
                <h5>FRIENDS</h5>
                <ul class="list-inline">

                    
                        <li><a href="https://palmerye.github.io/palmer-blog/" target="_blank">Palmer Blog</a></li>
                    
                </ul>
                
            </div>

        </div>
    </div>
</article>









    <!-- Footer -->
    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                
                
                
                    <li>
                        <a target="_blank" href="https://www.zhihu.com/people/yeomanyang">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa  fa-stack-1x fa-inverse">知</i>
                            </span>
                        </a>
                    </li>
                

                

                

                
                    <li>
                        <a target="_blank" href="https://github.com/yeomanyang">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; Yeoman&#39;s Blog 2019 
                    <br>
                    Theme by <a href="http://huangxuan.me">Hux</a> 
                    <span style="display: inline-block; margin: 0 5px;">
                        <i class="fa fa-heart"></i>
                    </span> 
                    Ported by <a href="http://blog.kaijun.rocks">Kaijun</a> | 
                    <iframe style="margin-left: 2px; margin-bottom:-5px;" frameborder="0" scrolling="0" width="91px" height="20px" src="https://ghbtns.com/github-btn.html?user=kaijun&repo=hexo-theme-huxblog&type=star&count=true">
                    </iframe>
                </p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js"></script>

<!-- Bootstrap Core JavaScript -->
<script src="/js/bootstrap.min.js"></script>

<!-- Custom Theme JavaScript -->
<script src="/js/hux-blog.min.js"></script>


<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- 
     Because of the native support for backtick-style fenced code blocks 
     right within the Markdown is landed in Github Pages, 
     From V1.6, There is no need for Highlight.js, 
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0  
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/    
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("https://yeomanyang.github.io/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->


<script>
    // dynamic User by Hux
    var _gaId = 'UA-90487102-1';
    var _gaDomain = 'undefined';

    // Originial
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', _gaId, _gaDomain);
    ga('send', 'pageview');
</script>




<!-- Baidu Tongji -->

<script>
    // dynamic User by Hux
    var _baId = 'c7f7936268a976be71b91508db530dfa';

    // Originial
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?" + _baId;
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
</script>


<!-- Side Catalog -->





<!-- Image to hack wechat -->
<img src="https://yeomanyang.github.io/img/icon_wechat.png" width="0" height="0" />
<!-- Migrate from head to bottom, no longer block render and still work -->

</body>

</html>
